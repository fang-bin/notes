# 前端模块化

随着电脑手机等智能设备性能配置、网络带宽、技术等提升，我们可以把网页做的更炫酷，更复杂、交互更加人性化也不会卡顿。但是这么搞下去，大量的js脚本代码略显其不好管理维护及团队配合开发，有些杂牌军的感觉。于是模块化开发应运而生。

没有模块化的时候，开发回有些比较头疼的问题，尤其多人开发时候，可能回出现一些问题：

1. 全局变量灾难（多个人命名了同一个全局变量）
2. 函数命名的冲突
3. 依赖关系不好处理（例： b.js依赖a.js，这时候的引用，b.js一定要放在a.js之后，顺序不能乱，更不能漏写）

解决上面一些问题，一开始时候一些解决方案：

1. 用自执行函数来包装代码

        modA = function(){
            var a,b; //变量a、b外部不可见
            return {
                add : function(c){
                    a + b + c;
                },
                format: function(){
                    //......
                }
            }
        }()

    这样function内部的变量就对全局隐藏了，达到是封装的目的。但是这样还是有缺陷的，modA这个变量还是暴漏到全局了，随着模块的增多，全局变量还是会越来越多。

2. jQuery风格的匿名自执行函数

        (function(window){
            //代码
            window.jQuery = window.$ = jQuery;//通过给window添加属性而暴漏到全局
        })(window);

    jQuery的封装风格曾经被很多框架模仿，通过匿名函数包装代码，所依赖的外部变量传给这个函数，在函数内部可以使用这些依赖，然后在函数的最后把模块自身暴漏给window。

    如果需要添加扩展，则可以作为jQuery的插件，把它挂载到$上。

    这种风格虽然灵活了些，但并未解决根本问题：所需依赖还是得外部提前提供、还是增加了全局变量。

    

AMD（异步模块定义） 是 RequireJS 在推广过程中对模块定义的规范化产出。

CMD（通用模块定义） 是 SeaJS 在推广过程中对模块定义的规范化产出。

类似的还有 CommonJS Modules/2.0 规范，是 BravoJS 在推广过程中对模块定义的规范化产出。

这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的。目前这些规范的实现都能达成浏览器端模块化开发的目的。

